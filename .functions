function color_name {
  if [ -z $USER ]; then echo -e "\e[95munknown" #if the variable is not present the color is magenta
  elif [ "$USER" = "root" ]; then echo -e "\e[31m$USER"  #if the user is root than the username color is red
  else echo -e "\e[33m$USER"  #otherwise print just the user name
  fi
}


function arrow {
  echo -E '▶';  
}


function block {
  echo -E '▬';  
}


function error { 
  # Check if the last command was a failure and then print a X
  [[ $? -gt 0 ]] && echo -E '✖'  
}


function bgjobs {
  # Check if the current user has background jobs and then print a gear
  [[ `jobs -l | wc -l` -gt 0 ]] && echo -E " ⚙"  
}


function docker_emoji {
  # Check if executed in a docker container and print the whale
  [[ -f /.dockerenv ]] && echo -E "🐋"
}


function update {
  if [[ `git status 2>&1` =~ 'Your branch is up to date' ]] && [[ `git status | wc -l` -eq "4" ]]; then 
    read -p "Do you want to check for update? [Y/n] " -n 1;
    if [[ $REPLY =~ ^[Yy]$ ]]; then 
      git remote -v update && echo "Update Success. Restart you terminal"
    elif [[ $REPLY =~ ^[Nn]$ ]]; then
      echo "Update skipped"
    else 
      echo "Unknown option. Terminating"
    fi
  fi
}


# Git Plugin
function gitPlugin () {    
  # Get the repository's branch for this repo
  gitString=''  #value return string

  # Get the current branch
  branch=`git symbolic-ref --short HEAD 2>/dev/null`  

  # Check if git is installed
  if [[ `git --version` ]]; then 
    # Check if it is a repository and if not so, just print the arrow to end the line
    if [[ `git status 2>&1` =~ 'ot a git repository' ]]; then  
      gitString+="\e[49m\e[34m$(arrow)"

    # Check if the branch is up to date with no mods, if so print a green banner with the branch symbol and the branch name
    else if [[ `git status 2>&1` =~ 'Your branch is up to date' ]] || [[ `git status | wc -l` -le "4" ]]; then  
      gitString+="\e[42m\e[34m"
      gitString+="$(arrow) "
      gitString+="\e[30m"
      gitString+=$'\u2387'
      gitString+=" \e[42m $branch \e[32m\e[49m$(arrow)"

    else
      # Yellow banner
      gitString+="\e[43m\e[38;5;04m$(arrow) \e[30m"
      gitString+=$'\u2387'
      gitString+="  $branch "

      # Print a plus meaning you have to do a `git add .`
      if [[ `git status 2>&1` =~ 'Changes not staged for commit' ]]; then   
        gitString+=$'\u271A'
        gitString+=" "
      fi

      # A big dot meaning you have to 'git commit'
      if [[ `git status 2>&1` =~ 'Changes to be committed' ]]; then 
        gitString+=$'\u25CF'
        gitString+=" "
      fi

      # An arrow pointing upwards, meaning you can push
      if [[ `git status 2>&1` =~ 'Your branch is ahead of' ]]; then
        gitString+=$'\u21D1'
        gitString+=" "
      fi

      # Ending part of the string
      gitString+="\e[49m\e[33m$(arrow)"
    fi
  fi
  echo -ne "$gitString"

  # If git isn't installed just always print the arrow
  else 
    echo -ne "\e[49m\e[34m$(arrow)" 
  fi
}


function gitPushAll() {
  if [ "$#" -eq "0" ]; then
    message="Mods applied to the Repo"
  else
    message="$1"
  fi

  git add --all
  git commit -m "$message"
  git push
}


function makeBackUpFile() {
  cp $1 $1.bak
  echo "made $1 backup file"
}


function cd_customized(){
  # cd is called with builtin prefix
  builtin cd "$@" 

  # Store current path (without spaces) and current path escaped
  current_path=$(pwd | sed -e 's/ /§/g')
  current_path_escaped=$(pwd | sed -e 's/\//\\\//g')

  # Check if the path already exist in the .cd file
  if [[ `grep -wE $current_path $PMP/.cd`  ]]; then
    # Upgrade the number of occurrencies of that line by one
    line_found=$(cat $PMP/.cd | grep -wE "$current_path" | awk -F '|' '{$1=$1+1; print $1" |"$2}')

    # Delete the old line 
    sed "/[0-9]+ \| $current_path_escaped/d" -i $PMP/.cd

    # Print the updated one
    echo "$line_found" >> $PMP/.cd

  else 
    # Path not found, so insert it in the .cd file
    echo "1 | $current_path" >> $PMP/.cd
  fi
}


function j(){
  # Sort stable, by number, in ascending order, by the first coloumn, then search the folder and move there
  cd "$(sort -sgrt '|' -k 1 $PMP/.cd | grep -w "$1$" | awk -F '|' '{ print $2; exit; }' | sed -e 's/§/\\\ /g' | xargs)"
}


function sshrc() {
  cat $PMP/.env $PMP/.functions $PMP/.aliases $PMP/.baschrc > $PMP/.sshrc
  scp -q "$PMP/.sshrc" "$PMP/.ssh_logout" "$1:/tmp"
  ssh -t $1 'echo "source /tmp/.sshrc" >> ~/.bashrc; echo "source /tmp/.ssh_logout" >> ~/.bash_logout; export PMP="/tmp"; exec bash -i'
}
