#!/bin/bash
export SHELL=/bin/bash
export PATH="$PATH:/usr/local/bin:$PMP/customized"
export EDITOR=vim
export LANG="en_US.UTF-8"
alias sudo='sudo '
alias fucking='sudo'
alias lsa='ls -la'
alias c='clear'
alias cl='clear;pwd;ls -la'
if [ -x /usr/bin/dircolors ]; then #ls with more color
	test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
  alias ls='ls --color=auto'
  alias dir='dir --color=auto'
  alias vdir='vdir --color=auto'
  alias grep='grep --color=auto'
  alias fgrep='fgrep --color=auto'
  alias egrep='egrep --color=auto'
fi
alias j=j
alias cd=cd_customized
alias ..='cd ../' 
alias ...='cd ../../'
alias ....='cd ../../../'
alias .....='cd ../../../../'
alias ......='cd ../../../../../'
alias ggg=gitPushAll
alias cleardns="sudo /etc/init.d/dns-clean restart && echo DNS cache cleared"
alias mbf=makeBackUpFile
alias filehost='vim /etc/hosts'
alias asites='cd /etc/apache2/sites-enabled'
alias nsites='cd /etc/nginx/sites-enabled'
alias restart='sudo systemctl restart '
alias start='sudo systemctl start '
alias reload='sudo systemctl reload '
alias stop='sudo systemctl stop '
alias install='sudo apt-get install'
alias sudorc='sudo -E -s'
alias s='sshrc'
function gitPlugin () {    
  # Get the repository's branch for this repo
  gitString=''  #value return string

  # Get the current branch
  branch=`git symbolic-ref --short HEAD 2>/dev/null`  

  # Check if git is installed
  if [[ `git --version` ]]; then 
    # Check if it is a repository and if not so, just print the arrow to end the line
    if [[ `git status 2>&1` =~ 'ot a git repository' ]]; then  
      gitString+="\e[49m\e[34m$(arrow)"

    # Check if the branch is up to date with no mods, if so print a green banner with the branch symbol and the branch name
    else if [[ `git status 2>&1` =~ 'Your branch is up to date' ]] || [[ `git status | wc -l` -le "4" ]]; then  
      gitString+="\e[42m\e[34m"
      gitString+="$(arrow) "
      gitString+="\e[30m"
      gitString+=$'\u2387'
      gitString+=" \e[42m $branch \e[32m\e[49m$(arrow)"

    else
      # Yellow banner
      gitString+="\e[43m\e[38;5;04m$(arrow) \e[30m"
      gitString+=$'\u2387'
      gitString+="  $branch "

      # Print a plus meaning you have to do a `git add .`
      if [[ `git status 2>&1` =~ 'Changes not staged for commit' ]]; then   
        gitString+=$'\u271A'
        gitString+=" "
      fi

      # A big dot meaning you have to 'git commit'
      if [[ `git status 2>&1` =~ 'Changes to be committed' ]]; then 
        gitString+=$'\u25CF'
        gitString+=" "
      fi

      # An arrow pointing upwards, meaning you can push
      if [[ `git status 2>&1` =~ 'Your branch is ahead of' ]]; then
        gitString+=$'\u21D1'
        gitString+=" "
      fi

      # Ending part of the string
      gitString+="\e[49m\e[33m$(arrow)"
    fi
  fi
  echo -ne "$gitString"

  # If git isn't installed just always print the arrow
  else 
    echo -ne "\e[49m\e[34m$(arrow)" 
  fi
}


function gitPushAll() {
  if [ "$#" -eq "0" ]; then
    message="Mods applied to the Repo"
  else
    message="$1"
  fi

  git add --all
  git commit -m "$message"
  git push
}

function cd_customized(){
  # cd is called with builtin prefix
  builtin cd "$@" 

  # Store current path (without spaces) and current path escaped
  current_path=$(pwd | sed -e 's/ /§/g')
  current_path_escaped=$(pwd | sed -e 's/\//\\\//g')

  # Check if the path already exist in the .cd file
  if [[ `grep -wE $current_path $PMP/.cd`  ]]; then
    # Upgrade the number of occurrencies of that line by one
    line_found=$(cat $PMP/.cd | grep -wE "$current_path" | awk -F '|' '{$1=$1+1; print $1" |"$2}')

    # Delete the old line 
    sed "/[0-9]+ \| $current_path_escaped/d" -i $PMP/.cd

    # Print the updated one
    echo "$line_found" >> $PMP/.cd

  else 
    # Path not found, so insert it in the .cd file
    echo "1 | $current_path" >> $PMP/.cd
  fi
}


function j(){
  # Sort stable, by number, in ascending order, by the first coloumn, then search the folder and move there
  cd "$(sort -sgrt '|' -k 1 $PMP/.cd | grep -w "$1$" | awk -F '|' '{ print $2; exit; }' | sed -e 's/§/\\\ /g' | xargs)"
}
function color_name {
  if [ -z $USER ]; then echo -e "\e[95munknown" #if the variable is not present the color is magenta
  elif [ "$USER" = "root" ]; then echo -e "\e[31m$USER"  #if the user is root than the username color is red
  else echo -e "\e[33m$USER"  #otherwise print just the user name
  fi
}


function arrow {
  echo -E '▶';  
}


function block {
  echo -E '▬';  
}


function error { 
  # Check if the last command was a failure and then print a X
  [[ $? -gt 0 ]] && echo -E '✖'  
}


function bgjobs {
  # Check if the current user has background jobs and then print a gear
  [[ `jobs -l | wc -l` -gt 0 ]] && echo -E " ⚙"  
}


function docker_emoji {
  # Check if executed in a docker container and print the whale
  [[ -f /.dockerenv ]] && echo -E "🐋"
}
function sshrc() {
  scp -q "$PMP/.sshrc" "$PMP/.ssh_logout" "$1:/tmp"
  ssh -t $1 'echo "source /tmp/.sshrc" >> ~/.bashrc; echo "source /tmp/.ssh_logout" >> ~/.bash_logout; export PMP="/tmp"; exec bash -i'
}
function update {
  if [[ `git status 2>&1` =~ 'Your branch is up to date' ]] && [[ `git status | wc -l` -eq "4" ]]; then 
    read -p "Do you want to check for update? [Y/n] " -n 1;
    if [[ $REPLY =~ ^[Yy]$ ]]; then 
      git remote -v update && echo "Update Success. Restart you terminal"
    elif [[ $REPLY =~ ^[Nn]$ ]]; then
      echo "Update skipped"
    else 
      echo "Unknown option. Terminating"
    fi
  fi
}

PMP=`ls -la ~ | grep ".bashrc" | awk -F '->' '{print $2}' | tr -d " \t\n\r" | rev | cut -d "/" -f2- | rev`

HISTCONTROL=ignorespace
# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=10000
HISTFILESIZE=20000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# append to the history file, don't overwrite it
shopt -s histappend

# make "less" more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

PS1='\[\e[40m\]'                              #background color black
PS1+='\[\e[31m\]'                             #text color red
PS1+="\$(error)"                              #calling the error function to check if the last command failed
PS1+="\$(docker_emoji)"
PS1+='\[\e[33m\]'                             #text color green
PS1+="\$(bgjobs)"                             #calling the function to check for backgorund jobs
PS1+=' \[\e[32m\]\D{%d/%m-%T} '               #dates in strftime(3): Day/month - hour:minute:second
PS1+='$(color_name)'                          #calling the function to check user color based on the user
PS1+='\[\e[39m@\]'                            #color for @ (white)
PS1+='\[\e[33m\]\h\[\e[30m\] '                #host
PS1+='\[\e[44m\]$(arrow)\[\e[30m\] '          #ending black arrow	
PS1+='\w'                                     #relative folder path
PS1+='\[\e[34m\]\[\e[44m\] '                  #adjusting colours for git plugin
PS1+="\$(gitPlugin)"                          #calling the function for the git plugin
PS1+='\[\e[49m\]\n'                           #next line
PS1+='\[\e[34m\]$(block)$(arrow)\[\e[0m\]  '; #second row with an arrow and a block

PS2='\[\e[34m\]\[\e[49m\]$(block)$(arrow)\[\e[0m\]  ';

