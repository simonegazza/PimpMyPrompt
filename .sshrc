#!/bin/bash
export SHELL=/bin/bash
export PATH="$PATH:/usr/local/bin"
export EDITOR=vim
export LANG="en_US.UTF-8"

# text colors and backgrounds
export background_blue='\[\e[44m\]'
export background_default='\[\e[49m\]'
export text_red='\[\e[31m\]'
export text_green='\[\e[32m\]'
export text_yellow='\[\e[33m\]'
export text_blue='\[\e[34m\]'
export remove_text_background='\[\e[0m\]'
export background_white='\[\e[40m\]'
export text_white='\[\e[30m\]'
export background_black='\[\e[107m\]'
export text_black='\[\e[39m\]'

function gitPlugin () {
  # Get the repository's branch for this repo
  gitString=''  #value return string

  # Get the current branch
  branch=`git symbolic-ref --short HEAD 2>/dev/null`

  # Check if git is installed
  if [[ `git --version` ]]; then
    # Check if it is a repository and if not so, just print the arrow to end the line
    if [[ `git status 2>&1` =~ 'ot a git repository' ]]; then
      gitString+="\e[49m\e[34m$(arrow)"

    # Check if the branch is up to date with no mods, if so print a green banner with the branch symbol and the branch name
    else if [[ `git status 2>&1` =~ 'Your branch is up to date' ]] && [[ `git status | wc -l` -le "4" ]]; then
      gitString+="\e[42m\e[34m"
      gitString+="$(arrow) "
      gitString+="\e[30m"
      gitString+=$'\u2387'
      gitString+=" \e[42m $branch \e[32m\e[49m$(arrow)"

    else
      # Yellow banner
      gitString+="\e[43m\e[38;5;04m$(arrow) \e[30m"
      gitString+=$'\u2387'
      gitString+="  $branch "

      # Print a plus meaning you have to do a `git add .`
      if [[ `git status 2>&1` =~ 'Changes not staged for commit' ]]; then
        gitString+=$'\u271A'
        gitString+=" "
      fi

      # A big dot meaning you have to 'git commit'
      if [[ `git status 2>&1` =~ 'Changes to be committed' ]]; then
        gitString+=$'\u25CF'
        gitString+=" "
      fi

      # An arrow pointing upwards, meaning you can push
      if [[ `git status 2>&1` =~ 'Your branch is ahead of' ]]; then
        gitString+=$'\u21D1'
        gitString+=" "
      fi

      # Ending part of the string
      gitString+="\e[49m\e[33m$(arrow)"
    fi
  fi
  echo -ne "$gitString"

  # If git isn't installed just always print the arrow
  else
    echo -ne "\e[49m\e[34m$(arrow)"
  fi
}

function gitPushAll() {
  if [ "$#" -eq "0" ]; then
    message="Mods applied to the Repo"
  else
    message="$1"
  fi

  git add --all
  git commit -m "$message"
  git push
}

function j () {
    while getopts ":lha:" o; do
        case ${o} in
        a)
            echo $(cd ${OPTARG} && pwd) >> $PMP/.cd
            return
        ;;
        h)
            echo "PimpMyPrompt jump, version 1.0
Usage: j [-a] folder
       j [-h|-l]
Arguments:
    -a      set the folder listed to be searched
    -l      show the list of folders
    -h      show this message"
            return
        ;;
        l)
            cat $PMP/.cd
            return
        ;;
        *)
        ;;
        esac
    done

    local query_folder=$(cd $1 && pwd)
    for folder in $(cat $PMP/.cd); do
        for subfolder in $(find $folder -type d); do
            if [[ "$subfolder" == "$query_folder" ]]; then
                cd $subfolder
                return
            fi
        done
    done
    echo "j: No match found"
}

function color_name {
  if [ -z $USER ]; then echo -e "\e[95munknown" #if the variable is not present the color is magenta
  elif [ "$USER" = "root" ]; then echo -e "\e[31m$USER"  #if the user is root than the username color is red
  else echo -e "\e[33m$USER"  #otherwise print just the user name
  fi
}

function arrow {
  echo -E '‚ñ∂';
}

function block {
  echo -E '‚ñ¨';
}

function error {
  # Check if the last command was a failure and then print a X
  [[ $? -gt 0 ]] && echo -E '‚úñ'
}

function bgjobs {
  # Check if the current user has background jobs and then print a gear
  [[ `jobs -l | wc -l` -gt 0 ]] && echo -E " ‚öô"
}

function docker_emoji {
  # Check if executed in a docker container and print the whale
  [[ -f /.dockerenv ]] && echo -E "üêã"
}

function gitPushAll() {
  if [ "$#" -eq "0" ]; then
    local message="Mods applied to the Repo"
  else
    local message="$1"
  fi

  git add --all
  git commit -m "$message"
  git push
}

function makeBackUpFile() {
  cp $1 $1.bakup
  echo "made $1 backup file"
}


function tree (){
    spaces=$((spaces+1))
    for file in `ls -A $1 | grep -v .git`; do
        for((i=1;i<=$spaces;i++)); do
             printf "    "
        done
        echo $file
        [[ -d "$1/$file" ]] && tree $1/$file
    done
    spaces=$((spaces-1))
}

function call_tree (){
    spaces=0
    echo $1
    tree $1
}

set completion-ignore-case On
set colored-stats On
set show-all-if-ambiguous On
set show-all-if-unmodified On
set echo-control-characters off
alias sudo='sudo '
alias fucking='sudo'
alias lsa='ls -la'
alias lsh='ls -lah'
alias c='clear'
alias cl='clear;pwd;ls -la'
if [ -x /usr/bin/dircolors ]; then #ls with more color
	test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
  alias ls='ls --color=auto'
  alias dir='dir --color=auto'
  alias vdir='vdir --color=auto'
  alias grep='grep --color=auto'
  alias fgrep='fgrep --color=auto'
  alias egrep='egrep --color=auto'
fi
alias ..='cd ../'
alias ...='cd ../../'
alias ....='cd ../../../'
alias .....='cd ../../../../'
alias ......='cd ../../../../../'
alias ggg=gitPushAll
alias gits="git status"
alias tree=call_tree
alias cleardns="sudo /etc/init.d/dns-clean restart && echo DNS cache cleared"
alias mbf=makeBackUpFile
alias filehost='vim /etc/hosts'
alias restart='sudo systemctl restart '
alias start='sudo systemctl start '
alias reload='sudo systemctl reload '
alias stop='sudo systemctl stop '
alias install='sudo apt-get install'
alias sudorc='sudo -E -s'

HISTCONTROL=ignorespace
# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=10000
HISTFILESIZE=20000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# append to the history file, don't overwrite it
shopt -s histappend

# make "less" more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

PS1="$background_black"                             #background color black
PS1+="$text_red\$(error)"                           #text color re and dcalling the error function to check if the last command failed
PS1+="\$(docker_emoji)"                             #emoji if in docker
PS1+="$text_yellow\$(bgjobs)"                       #text color yellow and calling the function to check for backgorund jobs
PS1+=" $text_green\D{%d/%m-%T} "                    #dates in strftime(3): Day/month - hour:minute:second
PS1+='$(color_name)'                                #calling the function to check user color based on the user
PS1+="$text_white@"                                 #color for @ (white)
PS1+="$text_yellow\h$text_black "                   #host
PS1+="$background_blue$(arrow)$text_black "         #ending black arrow
PS1+='\w'                                           #relative folder path
PS1+="$text_blue$background_blue \$(gitPlugin)"     #adjusting colours and calling git plugin
PS1+="$background_default\n"                        #next line
PS1+="$text_blue$(block)$(arrow)$remove_text_background  ";       #second row with an arrow and a block

PS2="$text_blue$background_default$(block)$(arrow)$remove_text_background  ";
